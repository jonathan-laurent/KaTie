// This query returns no matching. Since it is simple (i.e. it has a single event
// pattern), the snapshot measure should be taken lazily, and thus not at all in this
// case. If a snapshot is stored on disk (wrongly), the snapshot tests in the next query
// will fail due to the snapshot name `snapshot.0.json` being taken already.
query 'snapshots-lazy.csv'
match e:{ }
when sim_event_id[e] = 100
return snapshot[.e]


query 'expr_basic__matches_1__all_true.csv'
match e:{ +s:S() }
return
    // Testing basic measures
    time[e] > 0,
    rule[e] = 'create',
    debug_event[e] = 'new(S.0) free(S.0.x) mod(S.0.x, u)',
    int_state[e.]{s.x} = 'u',
    int_state[.e]{s.x} = null, // the agent does not exist yet
    agent_id{s} = 0, // first created agent
    event_id{e} = 0, // first event in the trace
    sim_event_id[e] = 1,
    size{component[e.]{s}} = 1,
    size{component[.e]{s}} = null,
    count{'S'}{component[e.]{s}} = 1,
    similarity{component[e.]{s}}{component[e.]{s}} = 1.0,
    similarity{component[.e]{s}}{component[e.]{s}} = null,
    print_cc[e.]{s} = 'x0:S(x{u}[.])',
    snapshot[.e] = 'tests/unit/expr-basic/katie-output/snapshots/snapshot.0.json',
    snapshot[e.] = 'tests/unit/expr-basic/katie-output/snapshots/snapshot.1.json',
    // Testing arithmetic and promotions
    1 + 1.0 = 2,
    1 - 1 = 0,
    2.0 * 4 = 8,
    not (1 > 1),
    2 > 1,
    1 >= 1,
    2 >= 1,
    not (1 < 1),
    1 < 2,
    1.0 <= 1,
    1 < 2.0,
    "aa" = "aa",
    not ("aa" = "bb"),
    (1 = 1 && 2 = 2),
    not (1 = 1 && 1 = 2),
    (1 = 1 || 1 = 2),
    not (1 = 2 || 2 = 3)