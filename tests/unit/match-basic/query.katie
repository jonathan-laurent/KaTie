query 'match_basic_trace.csv'
match e:{ }
return time[e], rule[e]

query 'create_S__matches_1__all_true.csv'
match e:{ +s:S() }
return int_state[e.]{s.x} = "u", rule[e] = "_init_"

// This one has a side effect.
//
// The '-Sp' event is as follows:
//     Is_Here(S/*0*/)
//     Has_Internal(S/*0*/.x{p})
//     Remove(S/*0*/)
//     Side_effects(S_0.x,*)
//     Side_effects(S_0.d,*)
query 'k_freed__matches_2__all_true.csv'
match e:{ K(d[/.]) }
return rule[e] = "_init_" || rule[e] = "-Sp"

// In contrast, this works as expected:
query 'unbinding__matches_1.csv'
match e:{ U1(x[/.]) }
return rule[e] = "U1..U2"

// (and this too of course)
query 'unbinding__matches_1__all_true.csv'
match e:{ U1(x[1/.]), U2(x[1/.]) }
return rule[e] = "U1..U2"

// WARNING: this one is tricky
// The tests are performed on the state BEFORE the rule is applied
// Here, the agent S does not exist yet when the x{u} test is performed.
query 'create_S_warn__matches_0.csv'
match e:{ +s:S(x{u}) }
return 1

// This works since we test the state update
query 'create_S_warn2__matches_1.csv'
match e:{ +s:S(x{/u}[/.]) }
return 1

// And this correctly does not match!
query 'create_S_warn3__matches_0.csv'
match e:{ +s:S(x{/p}) }
return 1

// This too!
query 'create_S_warn4__matches_0.csv'
match e:{ +s:S(x[/_]) }
return 1

query 'delete_S__matches_1.csv'
match e:{ -S() }
return 1

query 'delete_Sp__matches_1.csv'
match e:{ -s:S(x{p}) }
return 1

query 'delete_Su__matches_0.csv'
match e:{ -s:S(x{u}) }
return 1

query 'delete_Su_free__matches_0.csv'
match e:{ -s:S(x{u},d[.]) }
return 1

query 'delete_Su_bound_ok1__matches_1.csv'
match e:{ -s:S(x{p},d[d.K]) }
return 1

query 'delete_Su_bound_ok2__matches_1.csv'
match e:{ -s:S(x{p},d[_]) }
return 1

query 'delete_Su_bound_wrong1__matches_0.csv'
match e:{ -s:S(x{p},d[x.K]) }
return 1

query 'delete_Su_bound_wrong2__matches_0.csv'
match e:{ -s:S(x{p}[_]) }
return 1

// Let's look at bindings now

query 'bind_SK_1__matches_1__all_true.csv'
match e:{ S(d[/d.K]) }
return rule[e] = 'S.K'

query 'bind_SK_2__matches_1__all_true.csv'
match e:{ S(d[/_]) }
return rule[e] = 'S.K'

// Testing rule constraints

query 'rule_1__all_true.csv'
match e: { 'Sp' }
return rule[e] = 'Sp'

query 'rule_2__matches_2__all_true.csv'
match e: { 'Sp' | '-Sp' }
return rule[e] = 'Sp' || rule[e] = '-Sp'

query 'rule_3__matches_1__all_true.csv'
match e: { 'Sp' | '-Sp' -S()}
return rule[e] = '-Sp'

query 'rule_4__matches_0.csv'
match e: { 'Sp' | '-Sp' +S()}
return 1

// Testing the 'every' clause
// All these tests are tied to a specific random seed for KaSim and may break.
// Underlying trace:
// 0, '_init_'
// 0, '_init_'
// 0, '_init_'
// 0.8967991814821501, 'Kp'
// 0.9146156615284573, 'S.K'
// 2.0125168701922966, 'U1..U2'
// 2.9382127269136644, 'Sp'
// 4.2105040485343181, '-Sp'

query 'every_3__matches_1.csv'
match e:{} every 10 seconds
return time[e]

query 'every_2__matches_3.csv'
match e:{} every 1.0 seconds
return time[e]

query 'every_3__matches_5.csv'
match e:{} every 0.1 seconds
return time[e]

query 'every_rconstr__matches_2.csv'
match e:{'Kp' | 'Sp' | 'S.K'} every 0.1 seconds
return time[e]

// Testing the when clause

query 'when_1__matches_5__all_true.csv'
match e:{ }
when time[e] > 0
return not (rule[e] = "_init_")

query 'when_2__matches_0.csv'
match e:{ S(x{/p}) }
when not (rule[e] = "Sp")
return 1

// Warning: the 'every' clause is agnostic of 'when'.
// This is why it must be placed before it syntactically
query 'every_when_1__matches_0.csv'
match e:{}
every 1 seconds
when rule[e] = 'S.K'
return 1

query 'every_when_2__matches_1.csv'
match e:{ 'S.K' }
every 1 seconds
return 1

// Testing queries involving multiple events.

query 'multi_1__matches_1__all_true.csv'
match e:{ '-Sp' }
and last f:{ 'Sp' } before e
return time[f] < time[e]

query 'multi_2__matches_1__all_true.csv'
match f:{ 'Sp' }
and first e:{ '-Sp' } after f
return time[f] < time[e]

query 'multi_3__matches_1__all_true.csv'
match e:{ '-Sp' }
and last f:{ 'Sp' } before e
and first g: { '-Sp' } after f
return time[e] = time[g]

query 'multi_3_bis__matches_1__all_true.csv'
match e:{ '-Sp' -s:S() }
and last f:{ 'Sp' s:S(x{/p}) } before e
and first g: { '-Sp' -s:S() } after f
return time[e] = time[g]

query 'multi_4__matches_0__all_true.csv'
match e:{ '-Sp' }
and last f:{ 'Sp' } before e
and first g:{ '-Sp' } after e
return time[e] = time[g]

// OK
query 'multi_5__matches_1__all_true.csv'
match e:{ s:S(x{/p}, d[1]), k:K(d[1]) }
and last f:{ k:K(x{/p}) } before e
return rule[f] = 'Kp', rule[e] = 'Sp'

// OK
query 'multi_5_bis__matches_1__all_true.csv'
match f:{ k:K(x{/p}) }
and first e:{ S(x{/p}, d[1]), k:K(d[1]) } after f
return rule[f] = 'Kp', rule[e] = 'Sp'