query 'match_basic_trace.csv'
match e:{ }
return time[e], rule[e]

query 'create_S__matches_1__all_true.csv'
match e:{ +s:S() }
return int_state[e.]{s.x} = "u", rule[e] = "_init_"

// This one has a side effect
query 'k_freed__matches_2__all_true.csv'
match e:{ K(d[/.]) }
return rule[e] = "_init_" || rule[e] = "-Sp"

query 'unbinding__matches_1.csv'
match e:{ U1(x[/.]) }
return rule[e] = "U1..U2"

query 'unbinding__matches_1__all_true.csv'
match e:{ U1(x[1/.]), U2(x[1/.]) }
return rule[e] = "U1..U2"

query 'create_Sp__matches_0.csv'
match e:{ +s:S(x{p}) }
return 1

query 'create_Su__matches_1.csv'
match e:{ +s:S(x{u}) }
return 1

query 'create_U1U2__matches_1.csv'
match e:{ +U1(x[1]), +U2(x[1]) }
return 1

query 'create_U1U2_bis__matches_0.csv'
match e:{ +U1(x[1]), +U2(x[1]{p}) }
return 1

query 'delete_S__matches_1.csv'
match e:{ -S() }
return 1

query 'delete_Sp__matches_1.csv'
match e:{ -s:S(x{p}) }
return 1

query 'delete_Su__matches_0.csv'
match e:{ -s:S(x{u}) }
return 1

query 'delete_Su_free__matches_0.csv'
match e:{ -s:S(x{u},d[.]) }
return 1

query 'delete_Su_bound_ok1__matches_1.csv'
match e:{ -s:S(x{p},d[d.K]) }
return 1

query 'delete_Su_bound_ok2__matches_1.csv'
match e:{ -s:S(x{p},d[_]) }
return 1

query 'delete_Su_bound_wrong1__matches_0.csv'
match e:{ -s:S(x{p},d[x.K]) }
return 1

query 'delete_Su_bound_wrong2__matches_0.csv'
match e:{ -s:S(x{p}[_]) }
return 1

// Let's look at bindings now

query 'bind_SK_1__matches_1__all_true.csv'
match e:{ S(d[/d.K]) }
return rule[e] = 'S.K'

query 'bind_SK_2__matches_1__all_true.csv'
match e:{ S(d[/_]) }
return rule[e] = 'S.K'

// Testing rule constraints

query 'rule_1__all_true.csv'
match e: { 'Sp' }
return rule[e] = 'Sp'

query 'rule_2__matches_2__all_true.csv'
match e: { 'Sp' | '-Sp' }
return rule[e] = 'Sp' || rule[e] = '-Sp'

query 'rule_3__matches_1__all_true.csv'
match e: { 'Sp' | '-Sp' -S()}
return rule[e] = '-Sp'

query 'rule_4__matches_0.csv'
match e: { 'Sp' | '-Sp' +S()}
return 1

// Testing the 'every' clause
// All these tests are tied to a specific random seed for KaSim and may break.
// Underlying trace:
// 0, '_init_'
// 0, '_init_'
// 0, '_init_'
// 0.8967991814821501, 'Kp'
// 0.9146156615284573, 'S.K'
// 2.0125168701922966, 'U1..U2'
// 2.9382127269136644, 'Sp'
// 4.2105040485343181, '-Sp'

query 'every_3__matches_1.csv'
match e:{} every 10 seconds
return time[e]

query 'every_2__matches_3.csv'
match e:{} every 1.0 seconds
return time[e]

query 'every_3__matches_5.csv'
match e:{} every 0.1 seconds
return time[e]

query 'every_rconstr__matches_2.csv'
match e:{'Kp' | 'Sp' | 'S.K'} every 0.1 seconds
return time[e]

// Testing the when clause

query 'when_1__matches_5__all_true.csv'
match e:{ }
when time[e] > 0
return not (rule[e] = "_init_")

query 'when_2__matches_0.csv'
match e:{ S(x{/p}) }
when not (rule[e] = "Sp")
return 1

// Warning: the 'every' clause is agnostic of 'when'.
// This is why it must be placed before it syntactically
query 'every_when_1__matches_0.csv'
match e:{}
every 1 seconds
when rule[e] = 'S.K'
return 1

query 'every_when_2__matches_1.csv'
match e:{ 'S.K' }
every 1 seconds
return 1

// Testing queries involving multiple events.

query 'multi_1__matches_1__all_true.csv'
match e:{ '-Sp' }
and last f:{ 'Sp' } before e
return time[f] < time[e]

query 'multi_2__matches_1__all_true.csv'
match f:{ 'Sp' }
and first e:{ '-Sp' } after f
return time[f] < time[e]

query 'multi_3__matches_1__all_true.csv'
match e:{ '-Sp' }
and last f:{ 'Sp' } before e
and first g: { '-Sp' } after f
return time[e] = time[g]

query 'multi_3_bis__matches_1__all_true.csv'
match e:{ '-Sp' -s:S() }
and last f:{ 'Sp' s:S(x{/p}) } before e
and first g: { '-Sp' -s:S() } after f
return time[e] = time[g]

query 'multi_4__matches_0__all_true.csv'
match e:{ '-Sp' }
and last f:{ 'Sp' } before e
and first g:{ '-Sp' } after e
return time[e] = time[g]

query 'multi_5__matches_1__all_true.csv'
match e:{ s:S(x{/p}, d[1]), k:K(d[1]) }
and last f:{ k:K(x{/p}) } before e
return rule[f] = 'Kp', rule[e] = 'Sp'

query 'multi_5_bis__matches_1__all_true.csv'
match f:{ k:K(x{/p}) }
and first e:{ S(x{/p}, d[1]), k:K(d[1]) } after f
return rule[f] = 'Kp', rule[e] = 'Sp'

// Find the event that immediately follows in the trace
query 'multi_6__matches_1__all_true.csv'
match e:{ 'Sp' }
and first f:{ } after e
return rule[f] = "-Sp"

// Nothing after the last event
query 'multi_6_bis__matches_0.csv'
match e:{ '-Sp' }
and first f:{ } after e
return 1

// Find the event that immediately precedes in the trace
query 'multi_7__matches_1__all_true.csv'
match f:{ '-Sp' }
and last e:{ } before f
return rule[e] = "Sp"

// Match _init_: there are 3 init events so we get two consecutive pairs
query 'multi_8__matches_2__all_true.csv'
match f:{ '_init_' }
and last e:{ } before f
return rule[e] = "_init_"

query 'multi_8_bis__matches_1__all_true.csv'
match f:{ '_init_' +U1 }
and last e:{ } before f
return rule[e] = "_init_"


// u always matches the same event but e can match any previous event
query "multi_9.csv__matches_7__all_true"
match e:{ }
and first u:{ s:S(x[/.]) } after e
and u:{ s:S(x{p}) }
return int_state[.u]{s.x} = "p", rule[u] = "-Sp"

query "multi_9_bis.csv__matches_0__all_true"
match e:{ }
and first u:{ s:S(x[/.]) } after e
and u:{ s:S(x{u}) }
return 1


query "event_ids__matches_1__all_true.csv"
match e1:{ '_init_' }
and first e2:{ '_init_' } after e1
and first e3:{ '_init_' } after e2
return
    event_id{e1} = 0, sim_event_id[e1] = 0,
    event_id{e2} = 1, sim_event_id[e2] = 0,
    event_id{e3} = 2, sim_event_id[e3] = 0