query 'match_basic_trace.csv'
match e:{ }
return time[e], rule[e]

query 'create_S__matches_1__all_true.csv'
match e:{ +s:S() }
return int_state[e.]{s.x} = "u", rule[e] = "_init_"

// This only matches INIT? Interesting...
// Is this a BUG?
query 's_freed__matches_1__all_true.csv'
match e:{ S(d[/.]) }
return rule[e] = "_init_"

// In contrast, this works as expected:
query 'unbinding__matches_1.csv'
match e:{ U1(x[/.]) }
return rule[e] = "U1..U2"

// (and this too of course)
query 'unbinding__matches_1__all_true.csv'
match e:{ U1(x[1/.]), U2(x[1/.]) }
return rule[e] = "U1..U2"

// WARNING: this one is tricky
// The tests are performed on the state BEFORE the rule is applied
// Here, the agent S does not exist yet when the x{u} test is performed.
query 'create_S_warn__matches_0.csv'
match e:{ +s:S(x{u}) }
return 1

// This works since we test the state update
query 'create_S_warn2__matches_1.csv'
match e:{ +s:S(x{/u}[/.]) }
return 1

// And this correctly does not match!
query 'create_S_warn3__matches_0.csv'
match e:{ +s:S(x{/p}) }
return 1

// This too!
query 'create_S_warn4__matches_0.csv'
match e:{ +s:S(x[/_]) }
return 1

query 'delete_S__matches_1.csv'
match e:{ -S() }
return 1

query 'delete_Sp__matches_1.csv'
match e:{ -s:S(x{p}) }
return 1

query 'delete_Su__matches_0.csv'
match e:{ -s:S(x{u}) }
return 1

query 'delete_Su_free__matches_0.csv'
match e:{ -s:S(x{u},d[.]) }
return 1

query 'delete_Su_bound_ok1__matches_1.csv'
match e:{ -s:S(x{p},d[d.K]) }
return 1

query 'delete_Su_bound_ok2__matches_1.csv'
match e:{ -s:S(x{p},d[_]) }
return 1

query 'delete_Su_bound_wrong1__matches_0.csv'
match e:{ -s:S(x{p},d[x.K]) }
return 1

query 'delete_Su_bound_wrong2__matches_0.csv'
match e:{ -s:S(x{p}[_]) }
return 1

// Let's look at bindings now

query 'bind_SK_1__matches_1__all_true.csv'
match e:{ S(d[/d.K]) }
return rule[e] = 'S.K'

query 'bind_SK_2__matches_1__all_true.csv'
match e:{ S(d[/_]) }
return rule[e] = 'S.K'